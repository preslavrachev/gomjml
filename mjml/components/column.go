package components

import (
	"fmt"
	"strings"

	"github.com/preslavrachev/gomjml/mjml/html"
	"github.com/preslavrachev/gomjml/mjml/options"
	"github.com/preslavrachev/gomjml/mjml/styles"
	"github.com/preslavrachev/gomjml/parser"
)

// MJColumnComponent represents mj-column
// Columns enable you to horizontally organize the content within your sections.
// They must be located under mj-section tags in order to be considered by the engine.
// To be responsive, columns are expressed in terms of percentage.
// The sum of columns in a section cannot be greater than the width of the parent `mj-section` (or 100%).
// Every single column has to contain something because they are responsive containers, and will be vertically stacked on a mobile view.
// Any standard component, or component that you have defined and registered, can be placed within a column â€“ except mj-column or mj-section elements.
type MJColumnComponent struct {
	*BaseComponent
}

// NewMJColumnComponent creates a new mj-column component
func NewMJColumnComponent(node *parser.MJMLNode, opts *options.RenderOpts) *MJColumnComponent {
	return &MJColumnComponent{
		BaseComponent: NewBaseComponent(node, opts),
	}
}

func (c *MJColumnComponent) Render() (string, error) {
	var output strings.Builder

	// Helper function to get attribute with default
	getAttr := func(name string) string {
		if attr := c.GetAttribute(name); attr != nil {
			return *attr
		}
		return c.GetDefaultAttribute(name)
	}

	// Get attributes
	verticalAlign := getAttr("vertical-align")
	direction := getAttr("direction")

	// Get column class and mobile width following MRML logic
	className, _ := c.GetColumnClass()
	mobileWidth := c.GetMobileWidth()

	// Column div with MRML-style responsive styles matching exact property order
	// NOTE: MSO conditional TD is generated by the parent section component
	columnDiv := html.NewHTMLTag("div")
	c.AddDebugAttribute(columnDiv, "column")
	columnDiv.AddAttribute("class", c.BuildClassAttribute("mj-outlook-group-fix", className))

	// Always apply full column styles (same for all contexts)
	columnDiv.
		AddStyle("font-size", "0px").
		AddStyle("text-align", "left").
		AddStyle("direction", direction).
		AddStyle("display", "inline-block").
		AddStyle("vertical-align", verticalAlign).
		AddStyle("width", mobileWidth.String())

	// Apply background and border styles if any
	c.ApplyBackgroundStyles(columnDiv)
	c.ApplyBorderStyles(columnDiv)

	output.WriteString(columnDiv.RenderOpen())

	// Inner table for column content
	innerTable := html.NewTableTag().
		AddAttribute("width", "100%")

	// Add vertical-align for proper alignment - required for both section and group contexts
	innerTable.AddStyle("vertical-align", verticalAlign)

	output.WriteString(innerTable.RenderOpen())
	output.WriteString("<tbody>")

	// Render column content
	for _, child := range c.Children {
		childHTML, err := child.Render()
		if err != nil {
			return "", err
		}
		output.WriteString(childHTML)
	}

	output.WriteString("</tbody>")
	output.WriteString(innerTable.RenderClose())
	output.WriteString(columnDiv.RenderClose())

	return output.String(), nil
}

func (c *MJColumnComponent) GetTagName() string {
	return "mj-column"
}

func (c *MJColumnComponent) GetDefaultAttribute(name string) string {
	switch name {
	case "width":
		// Follow MRML logic: if no width specified, calculate auto width
		return c.getAutoWidthPercent()
	case "vertical-align":
		return "top"
	case "direction":
		return "ltr"
	case "text-align":
		return "left"
	default:
		return ""
	}
}

// getAutoWidthPercent calculates the auto width percentage based on MRML logic
// Size::percent(100.0 / (self.non_raw_siblings() as f32))
func (c *MJColumnComponent) getAutoWidthPercent() string {
	nonRawSiblings := c.GetNonRawSiblings()
	if nonRawSiblings <= 0 {
		nonRawSiblings = 1
	}
	widthPercent := 100.0 / float64(nonRawSiblings)
	return fmt.Sprintf("%.0f%%", widthPercent)
}

// GetParsedWidth returns the parsed width following MRML logic
func (c *MJColumnComponent) GetParsedWidth() styles.Size {
	if widthAttr := c.GetAttribute("width"); widthAttr != nil {
		if size, err := styles.ParseSize(*widthAttr); err == nil {
			return size
		}
	}
	// Default: auto-calculate percentage based on siblings
	nonRawSiblings := c.GetNonRawSiblings()
	if nonRawSiblings <= 0 {
		nonRawSiblings = 1
	}
	widthPercent := 100.0 / float64(nonRawSiblings)
	return styles.NewPercentSize(widthPercent)
}

// GetColumnClass returns the CSS class name and parsed width following MRML logic
// (String, Size) from get_column_class()
func (c *MJColumnComponent) GetColumnClass() (string, styles.Size) {
	parsedWidth := c.GetParsedWidth()
	var className string

	if parsedWidth.IsPercent() {
		// Format: mj-column-per-{width} where dots are replaced with dashes
		// Use float32 precision to match MRML's Rust f32 behavior
		f32Value := float32(parsedWidth.Value())
		widthStr := fmt.Sprintf("%g", f32Value)
		className = fmt.Sprintf("mj-column-per-%s", strings.ReplaceAll(widthStr, ".", "-"))
	} else {
		// Format: mj-column-px-{width} for pixel values
		widthStr := fmt.Sprintf("%.0f", parsedWidth.Value())
		className = fmt.Sprintf("mj-column-px-%s", strings.ReplaceAll(widthStr, ".", "-"))
	}

	return className, parsedWidth
}

// GetWidthAsPixel converts the parsed width to pixels for MSO compatibility
// Following MRML's get_width_as_pixel() logic
func (c *MJColumnComponent) GetWidthAsPixel() string {
	// Use the parent container's width, not the column's own width
	containerWidth := c.BaseComponent.GetEffectiveWidth()
	parsedWidth := c.GetParsedWidth()

	if containerWidth > 0 {
		if parsedWidth.IsPercent() {
			// Convert percentage to pixels
			pixelValue := float64(containerWidth) * parsedWidth.Value() / 100.0
			return fmt.Sprintf("%.0fpx", pixelValue)
		} else {
			// Already in pixels
			return parsedWidth.String()
		}
	}
	return "100%"
}

// GetMobileWidth returns the mobile width following MRML's get_mobile_width() logic
func (c *MJColumnComponent) GetMobileWidth() styles.Size {
	// Check if mobile-width attribute exists (MRML pattern - group sets this as signal)
	if c.GetAttribute("mobile-width") != nil {
		// Group context: use calculated width like MRML does
		return c.GetParsedWidth()
	}

	// If no mobile-width attribute, return 100% (MRML line 60)
	return styles.NewPercentSize(100.0)
}

// GetEffectiveWidth overrides BaseComponent to return the column's calculated pixel width
// instead of the inherited container width. This ensures child components get the correct width.
func (c *MJColumnComponent) GetEffectiveWidth() int {
	containerWidth := c.BaseComponent.GetEffectiveWidth()
	parsedWidth := c.GetParsedWidth()

	if containerWidth > 0 {
		if parsedWidth.IsPercent() {
			// Convert percentage to pixels
			pixelValue := float64(containerWidth) * parsedWidth.Value() / 100.0
			return int(pixelValue)
		} else {
			// Already in pixels
			return int(parsedWidth.Value())
		}
	}
	return containerWidth
}

// GetMSOTDStyles returns the styles that should be applied to the MSO conditional TD
// This is called by the parent section component, matching MRML's set_style_td_outlook
func (c *MJColumnComponent) GetMSOTDStyles() map[string]string {
	getAttr := func(name string) string {
		if attr := c.GetAttribute(name); attr != nil {
			return *attr
		}
		return c.GetDefaultAttribute(name)
	}

	verticalAlign := getAttr("vertical-align")

	// Calculate pixel width for MSO conditional using MRML logic
	msoPixelWidth := c.GetWidthAsPixel()

	return map[string]string{
		"vertical-align": verticalAlign,
		"width":          msoPixelWidth,
	}
}
