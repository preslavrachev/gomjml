package components

import (
	"io"
	"strconv"
	"strings"

	"github.com/preslavrachev/gomjml/mjml/constants"
	"github.com/preslavrachev/gomjml/mjml/html"
	"github.com/preslavrachev/gomjml/mjml/options"
	"github.com/preslavrachev/gomjml/mjml/styles"
	"github.com/preslavrachev/gomjml/parser"
)

// MJColumnComponent represents mj-column
// Columns enable you to horizontally organize the content within your sections.
// They must be located under mj-section tags in order to be considered by the engine.
// To be responsive, columns are expressed in terms of percentage.
// The sum of columns in a section cannot be greater than the width of the parent `mj-section` (or 100%).
// Every single column has to contain something because they are responsive containers, and will be vertically stacked on a mobile view.
// Any standard component, or component that you have defined and registered, can be placed within a column â€“ except mj-column or mj-section elements.
type MJColumnComponent struct {
	*BaseComponent
}

// NewMJColumnComponent creates a new mj-column component
func NewMJColumnComponent(node *parser.MJMLNode, opts *options.RenderOpts) *MJColumnComponent {
	return &MJColumnComponent{
		BaseComponent: NewBaseComponent(node, opts),
	}
}

func (c *MJColumnComponent) GetTagName() string {
	return "mj-column"
}

// calculateEffectiveContentWidth calculates the available content width for column children
// by subtracting the column's own padding from its actual width (not container width)
// AIDEV-NOTE: width-flow-core; column must subtract paddings before SetContainerWidth() calls to children
func (c *MJColumnComponent) calculateEffectiveContentWidth() int {
	// Use the column's own width, not the container width from section
	columnWidth := c.GetWidthAsPixel()
	containerWidth := 600 // fallback
	if len(columnWidth) > 2 && columnWidth[len(columnWidth)-2:] == "px" {
		// Parse without allocating substring
		if value, err := strconv.Atoi(columnWidth[:len(columnWidth)-2]); err == nil {
			containerWidth = value
		}
	}

	// Get column padding (defaults to no padding) using full attribute resolution
	padding := c.GetAttributeWithDefault(c, "padding")
	leftPadding, rightPadding := c.parsePaddingLeftRight(padding)

	// Subtract total horizontal padding
	effectiveWidth := containerWidth - leftPadding - rightPadding
	if effectiveWidth < 0 {
		effectiveWidth = containerWidth // fallback
	}

	return effectiveWidth
}

// parsePaddingLeftRight parses CSS padding shorthand to get left and right padding values in pixels
// Optimized to avoid allocations by parsing in place
func (c *MJColumnComponent) parsePaddingLeftRight(padding string) (left, right int) {
	if len(padding) == 0 {
		return 0, 0
	}

	// Fast path: single value like "20px"
	if len(padding) > 2 && padding[len(padding)-2:] == "px" {
		// Parse without allocating substring
		if value, err := strconv.Atoi(padding[:len(padding)-2]); err == nil {
			return value, value // same value for all sides
		}
	}

	// Handle "10px 25px" format by finding space separator
	spaceIdx := -1
	for i := 0; i < len(padding); i++ {
		if padding[i] == ' ' {
			spaceIdx = i
			break
		}
	}

	if spaceIdx > 0 {
		// Find second token (skip spaces)
		secondStart := spaceIdx + 1
		for secondStart < len(padding) && padding[secondStart] == ' ' {
			secondStart++
		}

		if secondStart < len(padding) && len(padding) > secondStart+2 && padding[len(padding)-2:] == "px" {
			// Parse second value (left/right padding)
			if value, err := strconv.Atoi(padding[secondStart : len(padding)-2]); err == nil {
				return value, value
			}
		}
	}

	return 0, 0
}

// Render implements optimized Writer-based rendering for MJColumnComponent
func (c *MJColumnComponent) Render(w io.StringWriter) error {
	// Get attributes using full resolution order (element, class, global, default)
	verticalAlign := c.GetAttributeWithDefault(c, "vertical-align")
	direction := c.GetAttributeWithDefault(c, "direction")

	// Get column class and mobile width following MRML logic
	className, _ := c.GetColumnClass()
	mobileWidth := c.GetMobileWidth()

	// Column div with MRML-style responsive styles matching exact property order
	// NOTE: MSO conditional TD is generated by the parent section component
	columnDiv := html.NewHTMLTag("div")
	c.AddDebugAttribute(columnDiv, "column")
	columnDiv.AddAttribute("class", c.BuildClassAttribute("mj-outlook-group-fix", className))

	// Always apply full column styles (same for all contexts)
	columnDiv.
		AddStyle("font-size", "0px").
		AddStyle("text-align", "left").
		AddStyle("direction", direction).
		AddStyle("display", "inline-block").
		AddStyle("vertical-align", verticalAlign).
		AddStyle("width", mobileWidth.String())

	if err := columnDiv.RenderOpen(w); err != nil {
		return err
	}

	// Check if we need gutter table for padding (following MJML JS pattern)
	if c.hasGutter() {
		if err := c.renderGutter(w); err != nil {
			return err
		}
	} else {
		if err := c.renderColumnToWriter(w); err != nil {
			return err
		}
	}

	if err := columnDiv.RenderClose(w); err != nil {
		return err
	}

	return nil
}

// renderColumnToWriter renders the column content directly to Writer
func (c *MJColumnComponent) renderColumnToWriter(w io.StringWriter) error {
	return c.renderColumnWithStylesToWriter(w, true)
}

// renderColumnWithStylesToWriter creates the inner column table with optional styles and writes to Writer
func (c *MJColumnComponent) renderColumnWithStylesToWriter(w io.StringWriter, includeStyles bool) error {
	// Inner table for column content
	innerTable := html.NewTableTag().AddAttribute("width", "100%")

	// Support inner background/border attributes following MRML behavior.
	innerBg := c.GetAttributeFast(c, "inner-background-color")
	innerBR := c.GetAttributeFast(c, "inner-border-radius")

	if includeStyles {
		// When no explicit inner background-color is provided, inherit
		// the column's background color only (columns don't emit
		// shorthand background style).
		if innerBg == "" {
			if bg := c.GetAttributeFast(c, "background-color"); bg != "" {
				innerTable.AddStyle("background-color", bg)
			}
		}

		if innerBR == "" {
			// Apply full border styles including radius when no
			// inner-radius override exists
			c.ApplyBorderStyles(innerTable, c)
		} else {
			// Apply border styles without border-radius so we can
			// set the inner radius separately
			toPtr := func(s string) *string {
				if s == "" {
					return nil
				}
				return &s
			}
			styles.ApplyBorderStyles(innerTable,
				toPtr(c.GetAttributeFast(c, constants.MJMLBorder)),
				nil,
				toPtr(c.GetAttributeFast(c, "border-top")),
				toPtr(c.GetAttributeFast(c, "border-right")),
				toPtr(c.GetAttributeFast(c, "border-bottom")),
				toPtr(c.GetAttributeFast(c, "border-left")),
			)
			innerTable.AddStyle("border-radius", innerBR)
		}

		verticalAlign := c.GetAttributeWithDefault(c, "vertical-align")
		innerTable.AddStyle("vertical-align", verticalAlign)
	} else {
		// Gutter path: apply "none" border defaults to inner table to
		// match MRML output when global attributes specify them.
		border := c.GetAttributeFast(c, constants.MJMLBorder)
		borderTop := c.GetAttributeFast(c, "border-top")
		borderRight := c.GetAttributeFast(c, "border-right")
		borderBottom := c.GetAttributeFast(c, "border-bottom")
		borderLeft := c.GetAttributeFast(c, "border-left")
		if border == "none" || borderTop == "none" || borderRight == "none" || borderBottom == "none" || borderLeft == "none" {
			toPtr := func(s string) *string {
				if s == "" {
					return nil
				}
				return &s
			}
			styles.ApplyBorderStyles(innerTable,
				toPtr(border),
				nil,
				toPtr(borderTop),
				toPtr(borderRight),
				toPtr(borderBottom),
				toPtr(borderLeft),
			)
		}
	}

	// Apply inner background/border overrides when present
	if innerBg != "" {
		innerTable.AddStyle("background-color", innerBg)
	}
	if innerBR != "" && !includeStyles {
		innerTable.AddStyle("border-radius", innerBR)
	}

	if err := innerTable.RenderOpen(w); err != nil {
		return err
	}
	if _, err := w.WriteString("<tbody>"); err != nil {
		return err
	}

	// Calculate effective content width for children by subtracting column padding
	effectiveWidth := c.calculateEffectiveContentWidth()

	// Render column content (child components)
	// AIDEV-NOTE: width-flow-children; SetContainerWidth passes effective width to children after subtracting column padding
	for _, child := range c.Children {
		// Set container width for child (like section does)
		child.SetContainerWidth(effectiveWidth)
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("</tbody>"); err != nil {
		return err
	}
	if err := innerTable.RenderClose(w); err != nil {
		return err
	}

	return nil
}

func (c *MJColumnComponent) GetDefaultAttribute(name string) string {
	switch name {
	case "width":
		// Follow MRML logic: if no width specified, calculate auto width
		return c.getAutoWidthPercent()
	case "vertical-align":
		return "top"
	case "direction":
		return "ltr"
	case "text-align":
		return "left"
	default:
		return ""
	}
}

// getAutoWidthPercent calculates the auto width percentage based on MRML logic
// Size::percent(100.0 / (self.non_raw_siblings() as f32))
func (c *MJColumnComponent) getAutoWidthPercent() string {
	nonRawSiblings := c.GetNonRawSiblings()
	if nonRawSiblings <= 0 {
		nonRawSiblings = 1
	}
	widthPercent := 100.0 / float64(nonRawSiblings)
	var b strings.Builder
	b.WriteString(strconv.FormatFloat(widthPercent, 'f', 0, 64))
	b.WriteString("%")
	return b.String()
}

// GetParsedWidth returns the parsed width following MRML logic
func (c *MJColumnComponent) GetParsedWidth() styles.Size {
	if widthAttr := c.GetAttribute("width"); widthAttr != nil {
		if size, err := styles.ParseSize(*widthAttr); err == nil {
			return size
		}
	}
	// Default: auto-calculate percentage based on siblings
	nonRawSiblings := c.GetNonRawSiblings()
	if nonRawSiblings <= 0 {
		nonRawSiblings = 1
	}
	widthPercent := 100.0 / float64(nonRawSiblings)
	return styles.NewPercentSize(widthPercent)
}

// GetColumnClass returns the CSS class name and parsed width following MRML logic
// (String, Size) from get_column_class()
func (c *MJColumnComponent) GetColumnClass() (string, styles.Size) {
	parsedWidth := c.GetParsedWidth()
	var className string

	if parsedWidth.IsPercent() {
		// Format: mj-column-per-{width} where dots are replaced with dashes
		f32Value := float32(parsedWidth.Value())
		widthStr := strconv.FormatFloat(float64(f32Value), 'g', -1, 32)
		className = "mj-column-per-" + strings.ReplaceAll(widthStr, ".", "-")
	} else {
		// Format: mj-column-px-{width} for pixel values
		widthStr := strconv.FormatFloat(parsedWidth.Value(), 'f', 0, 64)
		className = "mj-column-px-" + strings.ReplaceAll(widthStr, ".", "-")
	}

	return className, parsedWidth
}

// GetWidthAsPixel converts the parsed width to pixels for MSO compatibility
// Following MRML's get_width_as_pixel() logic
func (c *MJColumnComponent) GetWidthAsPixel() string {
	// Use the parent container's width, not the column's own width
	containerWidth := c.BaseComponent.GetEffectiveWidth()
	parsedWidth := c.GetParsedWidth()

	if containerWidth > 0 {
		if parsedWidth.IsPercent() {
			// Convert percentage to pixels
			pixelValue := float64(containerWidth) * parsedWidth.Value() / 100.0
			var b strings.Builder
			b.WriteString(strconv.FormatFloat(pixelValue, 'f', 0, 64))
			b.WriteString("px")
			return b.String()
		} else {
			// Already in pixels
			return parsedWidth.String()
		}
	}
	return "100%"
}

// GetMobileWidth returns the mobile width following MRML's get_mobile_width() logic
func (c *MJColumnComponent) GetMobileWidth() styles.Size {
	// Check if mobile-width attribute exists (MRML pattern - group sets this as signal)
	if c.GetAttribute("mobile-width") != nil {
		// Group context: use calculated width like MRML does
		return c.GetParsedWidth()
	}

	// If no mobile-width attribute, return 100% (MRML line 60)
	return styles.NewPercentSize(100.0)
}

// GetEffectiveWidth overrides BaseComponent to return the column's calculated pixel width
// instead of the inherited container width. This ensures child components get the correct width.
func (c *MJColumnComponent) GetEffectiveWidth() int {
	containerWidth := c.BaseComponent.GetEffectiveWidth()
	parsedWidth := c.GetParsedWidth()

	if containerWidth > 0 {
		if parsedWidth.IsPercent() {
			// Convert percentage to pixels
			pixelValue := float64(containerWidth) * parsedWidth.Value() / 100.0
			return int(pixelValue)
		} else {
			// Already in pixels
			return int(parsedWidth.Value())
		}
	}
	return containerWidth
}

// GetMSOTDStyles returns the styles that should be applied to the MSO conditional TD
// This is called by the parent section component, matching MRML's set_style_td_outlook
func (c *MJColumnComponent) GetMSOTDStyles() map[string]string {
	getAttr := func(name string) string {
		if attr := c.GetAttribute(name); attr != nil {
			return *attr
		}
		return c.GetDefaultAttribute(name)
	}

	verticalAlign := getAttr("vertical-align")

	// Calculate pixel width for MSO conditional using MRML logic
	msoPixelWidth := c.GetWidthAsPixel()

	return map[string]string{
		"vertical-align": verticalAlign,
		"width":          msoPixelWidth,
	}
}

// hasGutter checks if the column has any padding attributes
func (c *MJColumnComponent) hasGutter() bool {
	paddingAttrs := []string{constants.MJMLPadding, constants.MJMLPaddingTop, constants.MJMLPaddingRight, constants.MJMLPaddingBottom, constants.MJMLPaddingLeft}
	for _, attr := range paddingAttrs {
		if c.GetAttributeFast(c, attr) != "" {
			return true
		}
	}
	return false
}

// renderGutter creates the gutter table wrapper when padding is present
func (c *MJColumnComponent) renderGutter(w io.StringWriter) error {
	verticalAlign := c.GetAttributeWithDefault(c, "vertical-align")

	// Outer gutter table
	gutterTable := html.NewTableTag().AddAttribute("width", "100%")
	if err := gutterTable.RenderOpen(w); err != nil {
		return err
	}
	if _, err := w.WriteString("<tbody><tr>"); err != nil {
		return err
	}

	// TD with padding styles (this is where the padding gets applied)
	gutterTd := html.NewHTMLTag("td")
	// Columns should only emit background-color for compatibility
	if bg := c.GetAttributeFast(c, "background-color"); bg != "" {
		gutterTd.AddStyle("background-color", bg)
	}
	c.ApplyBorderStyles(gutterTd, c)
	gutterTd.AddStyle("vertical-align", verticalAlign)

	// Apply padding attributes to the gutter TD
	if padding := c.GetAttributeFast(c, "padding"); padding != "" {
		gutterTd.AddStyle("padding", padding)
	}
	if paddingTop := c.GetAttributeFast(c, constants.MJMLPaddingTop); paddingTop != "" {
		gutterTd.AddStyle(constants.CSSPaddingTop, paddingTop)
	}
	if paddingRight := c.GetAttributeFast(c, constants.MJMLPaddingRight); paddingRight != "" {
		gutterTd.AddStyle(constants.CSSPaddingRight, paddingRight)
	}
	if paddingBottom := c.GetAttributeFast(c, constants.MJMLPaddingBottom); paddingBottom != "" {
		gutterTd.AddStyle(constants.CSSPaddingBottom, paddingBottom)
	}
	if paddingLeft := c.GetAttributeFast(c, constants.MJMLPaddingLeft); paddingLeft != "" {
		gutterTd.AddStyle(constants.CSSPaddingLeft, paddingLeft)
	}

	if err := gutterTd.RenderOpen(w); err != nil {
		return err
	}

	// Inner column table (without styles since gutter TD handles them)
	if err := c.renderColumnWithStylesToWriter(w, false); err != nil {
		return err
	}

	if err := gutterTd.RenderClose(w); err != nil {
		return err
	}
	if _, err := w.WriteString("</tr></tbody>"); err != nil {
		return err
	}
	return gutterTable.RenderClose(w)
}
