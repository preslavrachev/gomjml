package components

import (
	"fmt"
	"io"
	"strings"

	"github.com/preslavrachev/gomjml/mjml/html"
	"github.com/preslavrachev/gomjml/mjml/options"
	"github.com/preslavrachev/gomjml/mjml/styles"
	"github.com/preslavrachev/gomjml/parser"
)

// MJColumnComponent represents mj-column
// Columns enable you to horizontally organize the content within your sections.
// They must be located under mj-section tags in order to be considered by the engine.
// To be responsive, columns are expressed in terms of percentage.
// The sum of columns in a section cannot be greater than the width of the parent `mj-section` (or 100%).
// Every single column has to contain something because they are responsive containers, and will be vertically stacked on a mobile view.
// Any standard component, or component that you have defined and registered, can be placed within a column â€“ except mj-column or mj-section elements.
type MJColumnComponent struct {
	*BaseComponent
}

// NewMJColumnComponent creates a new mj-column component
func NewMJColumnComponent(node *parser.MJMLNode, opts *options.RenderOpts) *MJColumnComponent {
	return &MJColumnComponent{
		BaseComponent: NewBaseComponent(node, opts),
	}
}

func (c *MJColumnComponent) GetTagName() string {
	return "mj-column"
}

// Render implements optimized Writer-based rendering for MJColumnComponent
func (c *MJColumnComponent) Render(w io.StringWriter) error {
	// Helper function to get attribute with default
	getAttr := func(name string) string {
		if attr := c.GetAttribute(name); attr != nil {
			return *attr
		}
		return c.GetDefaultAttribute(name)
	}

	// Get attributes
	verticalAlign := getAttr("vertical-align")
	direction := getAttr("direction")

	// Get column class and mobile width following MRML logic
	className, _ := c.GetColumnClass()
	mobileWidth := c.GetMobileWidth()

	// Column div with MRML-style responsive styles matching exact property order
	// NOTE: MSO conditional TD is generated by the parent section component
	columnDiv := html.NewHTMLTag("div")
	c.AddDebugAttribute(columnDiv, "column")
	columnDiv.AddAttribute("class", c.BuildClassAttribute("mj-outlook-group-fix", className))

	// Always apply full column styles (same for all contexts)
	columnDiv.
		AddStyle("font-size", "0px").
		AddStyle("text-align", "left").
		AddStyle("direction", direction).
		AddStyle("display", "inline-block").
		AddStyle("vertical-align", verticalAlign).
		AddStyle("width", mobileWidth.String())

	// Apply background and border styles if any
	c.ApplyBackgroundStyles(columnDiv)
	c.ApplyBorderStyles(columnDiv)

	if err := columnDiv.RenderOpen(w); err != nil {
		return err
	}

	// Check if we need gutter table for padding (following MJML JS pattern)
	if c.hasGutter() {
		if err := c.renderGutter(w); err != nil {
			return err
		}
	} else {
		if err := c.renderColumnToWriter(w); err != nil {
			return err
		}
	}

	if err := columnDiv.RenderClose(w); err != nil {
		return err
	}

	return nil
}

// renderColumnToWriter renders the column content directly to Writer
func (c *MJColumnComponent) renderColumnToWriter(w io.StringWriter) error {
	return c.renderColumnWithStylesToWriter(w, true)
}

// renderColumnWithStylesToWriter creates the inner column table with optional styles and writes to Writer
func (c *MJColumnComponent) renderColumnWithStylesToWriter(w io.StringWriter, includeStyles bool) error {
	// Inner table for column content
	innerTable := html.NewTableTag().AddAttribute("width", "100%")

	// Only add vertical-align when not inside a gutter (gutter TD handles vertical-align)
	if includeStyles {
		getAttr := func(name string) string {
			if attr := c.GetAttribute(name); attr != nil {
				return *attr
			}
			return c.GetDefaultAttribute(name)
		}
		verticalAlign := getAttr("vertical-align")
		innerTable.AddStyle("vertical-align", verticalAlign)
	}

	if err := innerTable.RenderOpen(w); err != nil {
		return err
	}
	if _, err := w.WriteString("<tbody>"); err != nil {
		return err
	}

	// Render column content (child components)
	for _, child := range c.Children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.WriteString("</tbody>"); err != nil {
		return err
	}
	if err := innerTable.RenderClose(w); err != nil {
		return err
	}

	return nil
}

func (c *MJColumnComponent) GetDefaultAttribute(name string) string {
	switch name {
	case "width":
		// Follow MRML logic: if no width specified, calculate auto width
		return c.getAutoWidthPercent()
	case "vertical-align":
		return "top"
	case "direction":
		return "ltr"
	case "text-align":
		return "left"
	default:
		return ""
	}
}

// getAutoWidthPercent calculates the auto width percentage based on MRML logic
// Size::percent(100.0 / (self.non_raw_siblings() as f32))
func (c *MJColumnComponent) getAutoWidthPercent() string {
	nonRawSiblings := c.GetNonRawSiblings()
	if nonRawSiblings <= 0 {
		nonRawSiblings = 1
	}
	widthPercent := 100.0 / float64(nonRawSiblings)
	return fmt.Sprintf("%.0f%%", widthPercent)
}

// GetParsedWidth returns the parsed width following MRML logic
func (c *MJColumnComponent) GetParsedWidth() styles.Size {
	if widthAttr := c.GetAttribute("width"); widthAttr != nil {
		if size, err := styles.ParseSize(*widthAttr); err == nil {
			return size
		}
	}
	// Default: auto-calculate percentage based on siblings
	nonRawSiblings := c.GetNonRawSiblings()
	if nonRawSiblings <= 0 {
		nonRawSiblings = 1
	}
	widthPercent := 100.0 / float64(nonRawSiblings)
	return styles.NewPercentSize(widthPercent)
}

// GetColumnClass returns the CSS class name and parsed width following MRML logic
// (String, Size) from get_column_class()
func (c *MJColumnComponent) GetColumnClass() (string, styles.Size) {
	parsedWidth := c.GetParsedWidth()
	var className string

	if parsedWidth.IsPercent() {
		// Format: mj-column-per-{width} where dots are replaced with dashes
		// Use float32 precision to match MRML's Rust f32 behavior
		f32Value := float32(parsedWidth.Value())
		widthStr := fmt.Sprintf("%g", f32Value)
		className = fmt.Sprintf("mj-column-per-%s", strings.ReplaceAll(widthStr, ".", "-"))
	} else {
		// Format: mj-column-px-{width} for pixel values
		widthStr := fmt.Sprintf("%.0f", parsedWidth.Value())
		className = fmt.Sprintf("mj-column-px-%s", strings.ReplaceAll(widthStr, ".", "-"))
	}

	return className, parsedWidth
}

// GetWidthAsPixel converts the parsed width to pixels for MSO compatibility
// Following MRML's get_width_as_pixel() logic
func (c *MJColumnComponent) GetWidthAsPixel() string {
	// Use the parent container's width, not the column's own width
	containerWidth := c.BaseComponent.GetEffectiveWidth()
	parsedWidth := c.GetParsedWidth()

	if containerWidth > 0 {
		if parsedWidth.IsPercent() {
			// Convert percentage to pixels
			pixelValue := float64(containerWidth) * parsedWidth.Value() / 100.0
			return fmt.Sprintf("%.0fpx", pixelValue)
		} else {
			// Already in pixels
			return parsedWidth.String()
		}
	}
	return "100%"
}

// GetMobileWidth returns the mobile width following MRML's get_mobile_width() logic
func (c *MJColumnComponent) GetMobileWidth() styles.Size {
	// Check if mobile-width attribute exists (MRML pattern - group sets this as signal)
	if c.GetAttribute("mobile-width") != nil {
		// Group context: use calculated width like MRML does
		return c.GetParsedWidth()
	}

	// If no mobile-width attribute, return 100% (MRML line 60)
	return styles.NewPercentSize(100.0)
}

// GetEffectiveWidth overrides BaseComponent to return the column's calculated pixel width
// instead of the inherited container width. This ensures child components get the correct width.
func (c *MJColumnComponent) GetEffectiveWidth() int {
	containerWidth := c.BaseComponent.GetEffectiveWidth()
	parsedWidth := c.GetParsedWidth()

	if containerWidth > 0 {
		if parsedWidth.IsPercent() {
			// Convert percentage to pixels
			pixelValue := float64(containerWidth) * parsedWidth.Value() / 100.0
			return int(pixelValue)
		} else {
			// Already in pixels
			return int(parsedWidth.Value())
		}
	}
	return containerWidth
}

// GetMSOTDStyles returns the styles that should be applied to the MSO conditional TD
// This is called by the parent section component, matching MRML's set_style_td_outlook
func (c *MJColumnComponent) GetMSOTDStyles() map[string]string {
	getAttr := func(name string) string {
		if attr := c.GetAttribute(name); attr != nil {
			return *attr
		}
		return c.GetDefaultAttribute(name)
	}

	verticalAlign := getAttr("vertical-align")

	// Calculate pixel width for MSO conditional using MRML logic
	msoPixelWidth := c.GetWidthAsPixel()

	return map[string]string{
		"vertical-align": verticalAlign,
		"width":          msoPixelWidth,
	}
}

// hasGutter checks if the column has any padding attributes
func (c *MJColumnComponent) hasGutter() bool {
	paddingAttrs := []string{"padding", "padding-top", "padding-right", "padding-bottom", "padding-left"}
	for _, attr := range paddingAttrs {
		if c.GetAttribute(attr) != nil {
			return true
		}
	}
	return false
}

// renderGutter creates the gutter table wrapper when padding is present
func (c *MJColumnComponent) renderGutter(w io.StringWriter) error {
	// Helper function to get attribute with default
	getAttr := func(name string) string {
		if attr := c.GetAttribute(name); attr != nil {
			return *attr
		}
		return c.GetDefaultAttribute(name)
	}

	verticalAlign := getAttr("vertical-align")

	// Outer gutter table
	gutterTable := html.NewTableTag().AddAttribute("width", "100%")
	if err := gutterTable.RenderOpen(w); err != nil {
		return err
	}
	if _, err := w.WriteString("<tbody><tr>"); err != nil {
		return err
	}

	// TD with padding styles (this is where the padding gets applied)
	gutterTd := html.NewHTMLTag("td")
	gutterTd.AddStyle("vertical-align", verticalAlign)

	// Apply padding attributes to the gutter TD
	if padding := c.GetAttribute("padding"); padding != nil {
		gutterTd.AddStyle("padding", *padding)
	}
	if paddingTop := c.GetAttribute("padding-top"); paddingTop != nil {
		gutterTd.AddStyle("padding-top", *paddingTop)
	}
	if paddingRight := c.GetAttribute("padding-right"); paddingRight != nil {
		gutterTd.AddStyle("padding-right", *paddingRight)
	}
	if paddingBottom := c.GetAttribute("padding-bottom"); paddingBottom != nil {
		gutterTd.AddStyle("padding-bottom", *paddingBottom)
	}
	if paddingLeft := c.GetAttribute("padding-left"); paddingLeft != nil {
		gutterTd.AddStyle("padding-left", *paddingLeft)
	}

	if err := gutterTd.RenderOpen(w); err != nil {
		return err
	}

	// Inner column table (without styles since gutter TD handles them)
	if err := c.renderColumnWithStylesToWriter(w, false); err != nil {
		return err
	}

	if err := gutterTd.RenderClose(w); err != nil {
		return err
	}
	if _, err := w.WriteString("</tr></tbody>"); err != nil {
		return err
	}
	return gutterTable.RenderClose(w)
}
